<head>
  <title>testapp</title>
  <meta charset="utf-8">
</head>

<body>
	<!--<pre>{{> character_docs}}</pre>-->
	<!--{{> d6_dice_roller}}-->
</body>

<template name="hello">
  <button>Click Me</button>
  <p>You've pressed the button {{counter}} times.</p>
</template>

<template name="test_tmplt">
	<p>test template</p>
	<p>{{testValue}}</p>
	{{testCl}}
</template>

<template name="d6_dice_roller">
	<p>Итак, начнем с простого. Мы имеем функцию, имитирующую шестигранную игральную кость.</p>
	<div>
		<code>
			<pre>
				function roll_d6()
				{
					//Базовый JS без дополнительных библиотек не обладает широким набором математических функций,
					//поэтому рандомайз в интервале приходится делать своими силами.
					//Math.random() возвращает случайное число от 0.0 до 1.0,
					//Поэтому домножаем на 5, чтобы получить значение от 0 до 6 
					//и прибавляем 1 для справедливого увеличения интервала 1 до 7.
					var random=Math.random()*6+1;
					//Возвращаем результат, округленный вниз.
					return Math.floor(random);
				}
			</pre>
		</code>
	</div>
	<button id="roll_d6_button">Roll dice</button>
	<span>Кость брошена {{d6_roll_number}} раз.</span>
	<p>Результат броска: {{d6_roll_current}}</p>
	<p> Кстати, по-хорошему эта функция должна быть более общей и выглядеть так:</p>
	<code>
		<pre>
			function roll_dice_of_type(type) //изменим функцию так, чтобы бросать кость с произвольным чслом граней
			{
				//наша функция принимает значение type в качестве произвольного входного параметра
				var random=Math.random()*type+1; //теперь при вызове функции нам просто стоит указать число граней
				return Math.floor(random);
			}
		</pre>
	</code>
	<p>
		Однако, вспомним, с чего все начиналось. 
		А именно - имитация игральной кости с помощью стогранного кубик. 
		В нашм случае речь шла о шестиграннике, но я опять приведу функцию для общего случая (количество граней меньше или равно ста).
	</p>
	<code>
		<pre>
			function roll_d100_like_other(type)
			{
				//В данном случае я просто округляю результат рандома вверх - Math.ceil().
				//Рандом*100 дает результат от 0 до 100, а округление вверх даст распределение от 1 до 100.
				var result = Math.ceil(100*Math.random());
				//Далее проверяю, не превышает ли результат заданное число граней.
				//И если превышает, перекидываю - вызываю эту функцию заново. Рекурсия, да.
				if (result>type) return roll_d100_like_other(type);
				else return result; //Как только результат попадает в нужный интерал, прекращаем содомию.
			}
		</pre>
	</code>
	<p>
		Посчитаем средние значения при, например, сотне бросках. Мне влом выводить все данные на экран
		(я не знаю, как, и у меня осталось не так много времени, чтобы это исправить), 
		поэтому используем еще одну простую функцию для подсчета среднего арифметического:
	</p>
	<code>
		<pre>
			roll_n_times: function(func,argument,n) //Функциональная мощь.
			{
				var result=0;
				for (var i=0; i&lt;n; i++)
				{
					result+=func(argument); //Да-да, это она.
				}
				return result/n;
			}
		</pre>
	</code>
	<p>
		Функция трех аргуметов. С циклом в теле. n - число повторений, это ясно.
		А из первых двух аргументов мы формируем вызов новой функции, что само по себе довольно забавно.
	</p>
	<p>Результат для сотни честных шестигранников - {{result_for_100d6}}</p>
	<p>Результат для сотни шестигранников, эмулированных стогранниками - {{result_for_100d100_d6_mode}}</p>
	<p>Что мы видим?</p>
	<p>Ах да, нужно нажать на кнопку, потому что иначе нихрена не работает.</p>
	<button id="roll_100d6_button">Roll!</button>
	<p>Какой-то пиздец.</p>
</template>
